// Comprehensive Auto-generated Tests
// Generated by CodeGuardian AI - Advanced Test Generator

import { 
  PriceCalculator, 
  UserValidator, 
  fibonacci, 
  isPalindrome, 
  fetchWithRetry 
} from './functions-for-testing';


    describe('PriceCalculator', () => {
      let calculator: PriceCalculator;

      beforeEach(() => {
        calculator = new PriceCalculator();
      });

      describe('calculateDiscount', () => {
        it('should calculate discount correctly for valid inputs', () => {
          expect(calculator.calculateDiscount(100, 20)).toBe(80);
          expect(calculator.calculateDiscount(50, 10)).toBe(45);
        });

        it('should throw error for invalid discount percentage', () => {
          expect(() => calculator.calculateDiscount(100, -5)).toThrow('Invalid discount percentage');
          expect(() => calculator.calculateDiscount(100, 101)).toThrow('Invalid discount percentage');
        });

        it('should throw error for non-positive price', () => {
          expect(() => calculator.calculateDiscount(0, 10)).toThrow('Price must be positive');
          expect(() => calculator.calculateDiscount(-10, 10)).toThrow('Price must be positive');
        });
      });

      describe('calculateBulkDiscount', () => {
        it('should calculate total for multiple items', () => {
          const items = [
            { price: 10, quantity: 2 },
            { price: 20, quantity: 1 }
          ];
          expect(calculator.calculateBulkDiscount(items)).toBe(40);
        });

        it('should handle empty array', () => {
          expect(calculator.calculateBulkDiscount([])).toBe(0);
        });
      });

      describe('applyTierDiscount', () => {
        it('should apply 15% discount for amounts >= 1000', () => {
          expect(calculator.applyTierDiscount(1000)).toBe(850);
        });

        it('should apply 10% discount for amounts >= 500', () => {
          expect(calculator.applyTierDiscount(500)).toBe(450);
        });

        it('should apply 5% discount for amounts >= 100', () => {
          expect(calculator.applyTierDiscount(100)).toBe(95);
        });

        it('should not apply discount for amounts < 100', () => {
          expect(calculator.applyTierDiscount(50)).toBe(50);
        });
      });
    });

    describe('UserValidator', () => {
      describe('validateEmail', () => {
        it('should return true for valid emails', () => {
          expect(UserValidator.validateEmail('test@example.com')).toBe(true);
          expect(UserValidator.validateEmail('user.name@domain.co.uk')).toBe(true);
        });

        it('should return false for invalid emails', () => {
          expect(UserValidator.validateEmail('invalid-email')).toBe(false);
          expect(UserValidator.validateEmail('@domain.com')).toBe(false);
          expect(UserValidator.validateEmail('test@')).toBe(false);
        });
      });

      describe('validatePassword', () => {
        it('should return valid for strong passwords', () => {
          const result = UserValidator.validatePassword('Password123');
          expect(result.valid).toBe(true);
          expect(result.errors).toHaveLength(0);
        });

        it('should return errors for weak passwords', () => {
          const result = UserValidator.validatePassword('weak');
          expect(result.valid).toBe(false);
          expect(result.errors.length).toBeGreaterThan(0);
        });

        it('should check minimum length', () => {
          const result = UserValidator.validatePassword('Aa1');
          expect(result.errors).toContain('Password must be at least 8 characters long');
        });

        it('should require uppercase letter', () => {
          const result = UserValidator.validatePassword('password123');
          expect(result.errors).toContain('Password must contain at least one uppercase letter');
        });

        it('should require lowercase letter', () => {
          const result = UserValidator.validatePassword('PASSWORD123');
          expect(result.errors).toContain('Password must contain at least one lowercase letter');
        });

        it('should require number', () => {
          const result = UserValidator.validatePassword('Password');
          expect(result.errors).toContain('Password must contain at least one number');
        });
      });

      describe('validateAge', () => {
        it('should return true for valid ages', () => {
          expect(UserValidator.validateAge(25)).toBe(true);
          expect(UserValidator.validateAge(0)).toBe(true);
          expect(UserValidator.validateAge(150)).toBe(true);
        });

        it('should return false for invalid ages', () => {
          expect(UserValidator.validateAge(-1)).toBe(false);
          expect(UserValidator.validateAge(151)).toBe(false);
          expect(UserValidator.validateAge(25.5)).toBe(false);
        });
      });
    });

    describe('fibonacci', () => {
      it('should return correct fibonacci numbers', () => {
        expect(fibonacci(0)).toBe(0);
        expect(fibonacci(1)).toBe(1);
        expect(fibonacci(2)).toBe(1);
        expect(fibonacci(3)).toBe(2);
        expect(fibonacci(4)).toBe(3);
        expect(fibonacci(5)).toBe(5);
        expect(fibonacci(10)).toBe(55);
      });

      it('should throw error for negative input', () => {
        expect(() => fibonacci(-1)).toThrow('Input must be non-negative');
      });

      it('should handle large numbers efficiently', () => {
        // Note: This might be slow for very large numbers
        expect(fibonacci(20)).toBe(6765);
      });
    });

    describe('isPalindrome', () => {
      it('should return true for palindromes', () => {
        expect(isPalindrome('racecar')).toBe(true);
        expect(isPalindrome('A man a plan a canal Panama')).toBe(true);
        expect(isPalindrome('race a car')).toBe(false);
      });

      it('should handle empty string', () => {
        expect(isPalindrome('')).toBe(true);
      });

      it('should handle single character', () => {
        expect(isPalindrome('a')).toBe(true);
      });

      it('should ignore case and special characters', () => {
        expect(isPalindrome('A!B@B#A')).toBe(true);
        expect(isPalindrome('Was it a car or a cat I saw?')).toBe(true);
      });
    });

    describe('fetchWithRetry', () => {
      beforeEach(() => {
        global.fetch = jest.fn();
      });

      afterEach(() => {
        jest.resetAllMocks();
      });

      it('should return response on first successful attempt', async () => {
        const mockResponse = { ok: true, status: 200 };
        (global.fetch as jest.Mock).mockResolvedValue(mockResponse);

        const result = await fetchWithRetry('http://example.com');
        expect(result).toBe(mockResponse);
        expect(global.fetch).toHaveBeenCalledTimes(1);
      });

      it('should retry on failure and succeed', async () => {
        const mockResponse = { ok: true, status: 200 };
        (global.fetch as jest.Mock)
          .mockRejectedValueOnce(new Error('Network error'))
          .mockResolvedValue(mockResponse);

        const result = await fetchWithRetry('http://example.com', 3);
        expect(result).toBe(mockResponse);
        expect(global.fetch).toHaveBeenCalledTimes(2);
      });

      it('should throw error after max retries', async () => {
        (global.fetch as jest.Mock).mockRejectedValue(new Error('Network error'));

        await expect(fetchWithRetry('http://example.com', 2))
          .rejects.toThrow('Network error');
        expect(global.fetch).toHaveBeenCalledTimes(2);
      });

      it('should wait between retries', async () => {
        (global.fetch as jest.Mock).mockRejectedValue(new Error('Network error'));
        
        const startTime = Date.now();
        try {
          await fetchWithRetry('http://example.com', 2);
        } catch (error) {
          // Expected to fail
        }
        const endTime = Date.now();
        
        // Should have waited at least 1 second for the retry
        expect(endTime - startTime).toBeGreaterThan(1000);
      });
    });

// Performance Tests
describe('Performance Tests', () => {
  it('should handle large datasets efficiently', () => {
    const calculator = new PriceCalculator();
    const largeItems = Array.from({ length: 1000 }, (_, i) => ({
      price: Math.random() * 100,
      quantity: Math.floor(Math.random() * 10) + 1
    }));
    
    const startTime = performance.now();
    calculator.calculateBulkDiscount(largeItems);
    const endTime = performance.now();
    
    expect(endTime - startTime).toBeLessThan(100); // Should complete in less than 100ms
  });
});

// Security Tests
describe('Security Tests', () => {
  describe('Input Sanitization', () => {
    it('should handle malicious email inputs', () => {
      const maliciousInputs = [
        '<script>alert("xss")</script>@example.com',
        'test@<script>alert("xss")</script>.com',
        '../../etc/passwd@example.com'
      ];
      
      maliciousInputs.forEach(input => {
        expect(UserValidator.validateEmail(input)).toBe(false);
      });
    });

    it('should prevent ReDoS attacks on email validation', () => {
      const maliciousInput = 'a'.repeat(10000) + '@example.com';
      
      const startTime = performance.now();
      UserValidator.validateEmail(maliciousInput);
      const endTime = performance.now();
      
      expect(endTime - startTime).toBeLessThan(1000); // Should not take more than 1 second
    });
  });
});
